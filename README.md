# "Ханойская башня"

## 1. Анализ и постановка задачи
Необходимо разработать программу для решения классической головоломки **«Ханойская башня»**.
Задача: перенести `n` дисков с исходного стержня (A) на целевой (C), используя промежуточный стержень (B).

**Условия:**
- Перемещать можно только один диск за один ход.
- Диск большего размера нельзя помещать на меньший.

**Цель:**
- Вычислить минимальную последовательность ходов (всего `2^n - 1`).
- Отобразить пошаговое решение с визуализацией состояния башен.
- Вывести время выполнения алгоритма на экран


## 2. Построение модели
- **Диски**: имеют уникальные размеры от `1` (наименьший) до `n` (наибольший).
- **Стержни**: три башни, обозначенные как `A`, `B`, `C`.
- **Состояние башен**: хранится в виде трёх стеков (векторов).

**Ограничения:**
- Допускается только перемещение верхнего диска.
- Нарушать правило «меньший сверху большего» запрещено.


## 3. Разработка алгоритма
Алгоритм строится на рекурсии:
func(n, from, to, aux):
  если n == 0:
    завершить
  если n == 1:
    переместить диск с from на to
  иначе:
    func(n-1, from, aux, to)
    переместить диск с from на to
    func(n-1, aux, to, from)

- Базовый случай: перенос одного диска напрямую.
- Рекурсивный случай: перенос «башни» из `n-1` дисков на вспомогательный стержень, перенос самого большого диска, затем возврат «башни» на целевой стержень.

## 4. Проверка правильности алгоритма
- Для `n = 1`: решение одноходовое.
  
<img width="217" height="148" alt="Screenshot 2025-09-16 at 23 37 15" src="https://github.com/user-attachments/assets/6401e3dd-c31d-4f5c-8a13-961085a046c1" />

- Для `n = 2`: три хода (совпадает с `2^2 - 1`).

<img width="442" height="169" alt="Screenshot 2025-09-16 at 23 35 46" src="https://github.com/user-attachments/assets/e9ea1233-ba94-4f12-a00e-83920a2ba273" />

  
- Для `n = 3`: семь ходов (совпадает с `2^3 - 1`).

<img width="254" height="187" alt="Screenshot 2025-09-16 at 23 36 36" src="https://github.com/user-attachments/assets/71df35cb-0d57-4040-82c1-c27263528ee9" />

  
- Правила не нарушаются: перемещается только верхний диск, больший никогда не оказывается на меньшем.


## 5. Реализация алгоритма в виде программы
Программа написана на языке **C++**.

- В коде создан класс `Solution`, который:
  - хранит состояние башен (`vector<vector<int>> towers`),
  - выполняет перемещения через метод `moveDisk()`,
  - решает задачу с помощью рекурсивной функции `func()`.
- Для визуализации реализован метод `printTowers()`, который отображает текущее состояние башен в **ASCII-графике**, где диски изображаются символами `#`.
- В `main()` пользователь вводит количество дисков, запускается решение с пошаговым выводом.

## 6. Анализ алгоритма и его сложности
- **Количество шагов**: строго равно `2^n - 1`.
- **Временная сложность**: `O(2^n)`.
- **Пространственная сложность**:
  - `O(n)` — глубина рекурсии,
  - `O(n)` — хранение состояния башен.

## 7. Проверка программы

Программа протестирована на нескольких случаях:
- При `n = 1`: выводится 1 ход, башня переносится корректно. (рис.1)
- При `n = 2`: 3 хода, решение совпадает с ожидаемым. (рис.2)
- При `n = 3`: 7 шагов, диски переносятся в правильном порядке, визуализация соответствует состояниям башен. (рис.3)
- При больших `n` (например, `n = 5`) программа строит корректную последовательность и выводит её, но количество шагов быстро растёт экспоненциально.

| Рисунок 1 | Рисунок 2 | Рисунок 3 |
|--------------------|------------|-------------------|
| <img src="https://github.com/user-attachments/assets/113437ae-e524-4098-8147-8cb04930f71a" width="300"> | <img src="https://github.com/user-attachments/assets/1b82adb5-39d6-46c3-a3e7-8d6ef8333653" width="300"> | <img src="https://github.com/user-attachments/assets/047617af-5818-44ee-bd2e-f1e266539d54" width="300"> |

